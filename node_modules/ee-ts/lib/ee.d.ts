import { Disposable, EventIn, EventKey, EventOut, Listener, ListenerMap } from './types';
export * from './types';
export declare const $listeners: unique symbol;
export declare const $addListener: unique symbol;
/** Statically typed event emitter */
export declare class EventEmitter<T> {
    [$listeners]: {
        [K in EventKey<T>]?: IListenerList<T, K>;
    };
    constructor();
    /** Unique symbol for accessing the internal listener cache */
    static readonly ev: symbol;
    /** Count the number of listeners for an event */
    static count<T>(ee: EventEmitter<T>, key: EventKey<T>): number;
    /** Check if an event has listeners */
    static has<T>(ee: EventEmitter<T>, key: '*' | EventKey<T>): boolean;
    /** Get an array of event keys that have listeners */
    static keys<T>(ee: EventEmitter<T>): Array<EventKey<T>>;
    /** Call the given listener when no other listeners exist */
    static unhandle<T, K extends EventKey<T>>(ee: EventEmitter<T>, key: K, impl: Listener<T, K>, disposables?: Disposable[]): typeof impl;
    /** Add a recurring listener */
    on<K extends EventKey<T>>(key: K, fn: Listener<T, K>, disposables?: Disposable[]): typeof fn;
    /** Add many recurring listeners */
    on(map: ListenerMap<T>, disposables?: Disposable[]): this;
    /** Add a one-time listener */
    one<K extends EventKey<T>>(key: K, fn: Listener<T, K>): typeof fn;
    /** Add many one-time listeners */
    one(map: ListenerMap<T>): this;
    /** Remove one or all listeners of an event */
    off<K extends EventKey<T>>(key: K, fn?: Listener<T, K>): this;
    /** Remove all listeners from all events */
    off(key: '*'): this;
    /** Call the listeners of an event */
    emit<K extends EventKey<T>>(key: K, ...args: EventIn<T, K>): EventOut<T, K>;
    /** Iterate over the listeners of an event */
    listeners<K extends EventKey<T>>(key: K): IterableIterator<Listener<T, K>>;
    /** Called when an event goes from 0 -> 1 listeners */
    protected _onEventHandled?(key: string): void;
    /** Called when an event goes from 1 -> 0 listeners */
    protected _onEventUnhandled?(key: string): void;
    /** Implementation of the `on` and `one` methods */
    protected [$addListener](arg: EventKey<T> | ListenerMap<T>, fn?: Listener<T>, disposables?: Disposable[], once?: boolean): this | Listener<T>;
}
interface IListener<T, K extends EventKey<T> = EventKey<T>> {
    fn: Listener<T, K>;
    once: boolean;
    next: IListener<T, K> | null;
}
interface IListenerList<T, K extends EventKey<T> = EventKey<T>> {
    first: IListener<T, K>;
    last: IListener<T, K>;
}
