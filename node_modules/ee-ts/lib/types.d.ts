declare type Id<T> = T;
declare type In<T> = T extends (...args: infer U) => any ? U : [];
declare type Out<T> = T extends (...args: any[]) => infer U ? U : never;
declare type Filter<T, Cond, U extends keyof T = keyof T> = {
    [K in U]: T[K] extends Cond ? K : never;
}[U];
export declare type EventKey<T> = Filter<T, (...args: any[]) => any> & string;
export declare type EventIn<T, K extends EventKey<T>> = Id<In<T[K]>>;
export declare type EventOut<T, K extends EventKey<T>> = Id<Out<T[K]> | void>;
/** An object that needs to be manually disposed of */
export interface Disposable {
    dispose(): void;
}
/** Extract the listener type for a specific event */
export declare type Listener<T = any, K extends EventKey<T> = EventKey<T>> = Id<(...args: EventIn<T, K>) => EventOut<T, K>>;
/** An object of event keys and listener values */
export declare type ListenerMap<T = any> = Partial<{
    [K in EventKey<T>]: Listener<T, K>;
}>;
export {};
